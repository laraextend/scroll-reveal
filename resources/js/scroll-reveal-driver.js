/*!
 * scroll-reveal-driver.js
 * Part of laraextend/scroll-reveal — https://github.com/laraextend/scroll-reveal
 *
 * Zero-dependency scroll-reveal driver powered by the native Intersection Observer API.
 *
 * Reads data-sr-* attributes generated by <x-scroll-reveal>:
 *   data-sr-anim      — Animate.css animation name (e.g. "fadeInUp")
 *   data-sr-duration  — Animation duration         (e.g. "700ms")
 *   data-sr-delay     — Animation delay            (e.g. "0.2s")
 *
 * Usage:
 *   new ScrollRevealDriver({ initClass: 'animateme', offset: 0.2 });
 */
(function (global) {
    'use strict';

    class ScrollRevealDriver {
        /**
         * @param {object}  [options]
         * @param {string}  [options.initClass='animateme']  CSS class that marks elements to animate.
         * @param {number}  [options.offset=0.2]             Intersection threshold (0.0 – 1.0).
         * @param {boolean} [options.animateOut=false]        Re-animate when element leaves + re-enters.
         */
        constructor(options = {}) {
            this.initClass  = options.initClass  ?? 'animateme';
            this.threshold  = options.offset     ?? 0.2;
            this.animateOut = options.animateOut  ?? false;
            this._observer  = null;
            this._init();
        }

        _init() {
            const els = document.querySelectorAll('.' + this.initClass);

            if (!('IntersectionObserver' in window)) {
                // Fallback for very old browsers: show all elements immediately.
                els.forEach(el => this._animate(el));
                return;
            }

            if (!els.length) return;

            this._observer = new IntersectionObserver(entries => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        this._animate(entry.target);
                        if (!this.animateOut) {
                            this._observer.unobserve(entry.target);
                        }
                    } else if (this.animateOut) {
                        // Reset so the animation plays again on next entry.
                        this._reset(entry.target);
                    }
                });
            }, { threshold: this.threshold });

            els.forEach(el => this._observer.observe(el));
        }

        _animate(el) {
            const name     = el.dataset.srAnim     || 'fadeInUp';
            const duration = el.dataset.srDuration || '700ms';
            const delay    = el.dataset.srDelay    || '';

            el.style.animationDuration = duration;
            el.style.animationDelay    = delay;
            el.style.animationFillMode = 'both';

            // Animate.css v4 uses the `animate__` prefix.
            el.classList.add('animate__animated', 'animate__' + name);
        }

        _reset(el) {
            const name = el.dataset.srAnim || 'fadeInUp';
            el.classList.remove('animate__animated', 'animate__' + name);
            el.style.animationFillMode = '';
            el.style.animationDelay    = '';
        }

        /** Disconnect the observer and stop watching all elements. */
        destroy() {
            if (this._observer) {
                this._observer.disconnect();
                this._observer = null;
            }
        }
    }

    global.ScrollRevealDriver = ScrollRevealDriver;

}(typeof globalThis !== 'undefined' ? globalThis : window));
